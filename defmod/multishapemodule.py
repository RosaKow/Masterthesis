import torch
import numpy as np

from kernels import K_xx, K_xy


class MultiShapeModule(torch.nn.Module):

    """ Input: List of modules (length n), the nth module is the background module; 
               constraints as a matrix """
    def __init__(self, module_list, Constr):
        super().__init__()
        self.__module_list = module_list
        self.__nb_module = len(module_list)
        self.__dim_gd = sum([mod.dim_gd for mod in module_list])
        self.__dim_controls = sum([mod.dim_controls for mod in module_list])
        self.__indice_gd = [0]
        self.__indice_gd.extend(np.cumsum([mod.dim_gd for mod in module_list]))
        self.__indice_controls = [0]
        self.__indice_controls.extend(np.cumsum([mod.dim_controls for mod in module_list]))
        self.__nb_pts = sum(mod.nb_pts for mod in module_list)
        
    
    @property
    def module_list(self):
        return self.__module_list

    @property
    def nb_module(self):
        return self.__nb_module

    @property
    def dim_gd(self):
        return self.__dim_gd

    @property
    def dim_controls(self):
        return self.__dim_controls

    @property
    def indice_gd(self):
        return self.__indice_gd

    @property
    def indice_controls(self):
        return self.__indice_controls

    @property
    def nb_pts(self):
        return self.__nb_pts

    
    def __call__(self, gd, controls, points, indice_points) :
        app_list = []
        for i in range(self.__nb_module):
            tmp = torch.zeros([1, points.shape[0], points.shape[1]])
            tmp[:, indice_points[i]:indice_points[i+1], :] = self.__module_list[i](
                gd[self.__indice_gd[i]:self.__indice_gd[i+1]],
                controls[self.__indice_controls[i]:self.__indice_controls[i+1]],
                points[indice_points[i]:indice_points[i+1]]
            )
            app_list.append(tmp)
        return torch.sum(torch.cat(app_list), 0)

    def action(self, gd, module, gd_module, controls_module) :
        """Applies the vector field generated by Mod on GeoDesc."""
        app_list = []
        for i in range(self.__nb_module):
            tmp = torch.zeros([1, gd.shape[0], gd.shape[1]])
            tmp[:, self.indice_gd[i]:self.indice_gd[i+1], :] = self.__module_list[i].action(
                gd[self.indice_gd[i]:self.indice_gd[i+1]], module,
                gd_module, controls_module)
            app_list.append(tmp)

        return torch.cat(app_list)

    def cost(self, gd, controls) :
        """Returns the cost."""
        cost_list = []
        for i in range(self.__nb_module):
            cost_list.append(self.__module_list[i].cost(
                gd[self.__indice_gd[i]:self.__indice_gd[i+1]],
                controls[self.__indice_controls[i]:self.__indice_controls[i+1]]
            ).unsqueeze(0))
                             
        return torch.sum(torch.cat(cost_list), 0)


    def inverse_cost(self, delta, GeoDesc):
        """Computes geodesic control from \delta \in H^\ast."""
        controls_list = []
        for i in range(self.__nb_module):
            controls_list.append(self.__module_list[i].compute_geodesic_control(
                delta[self.__indice_controls[i]:self.__indice_controls[i+1]],
                GeoDesc[self.indice_gd[i]:self.indice_gd[i+1]])
            )
        return torch.cat(controls_list)


    def constraints(self, modules, gd, controls, boundary_points):
        """ Computes the value of Constraints on v """
        #constr_list = []        
        #for i in range(self.__nb_module-1):
        #    if constraints_list[i] == 'identity'
        #        for i in range(nb_modules-1)
        #            constr_list.append(modules[i].action(
        #                boundary_points[self.__indice_controls[i]:self.__indice_controls[i+1]], 
        #                modules_list[i], gd[self.__indice_controls[i]:self.__indice_controls[i+1]], 
        #                controls[self.__indice_controls[i]:self.__indice_controls[i+1]]) 
        #            - modules[nb_modules].action(
        #                boundary_points[self.__indice_controls[nb_modules-1]:self.__indice_controls[nb_modules]], 
        #                modules[self.__indice_controls[nb_modules-1]:self.__indice_controls[nb_modules]], 
        #                gd[self.__indice_controls[nb_modules-1]:self.__indice_controls[nb_modules]], 
        #                controls[self.__indice_controls[nb_modules-1]:self.__indice_controls[nb_modules]])
        return 
    