import copy

import torch
import numpy as np


class Manifold:
    def __init__(self):
        super().__init__()

    def copy(self):
        return copy.copy(self)

    @property
    def dim_gd(self):
        raise NotImplementedError

    def action(self, module):
        raise NotImplementedError


class Landmarks(Manifold):
    def __init__(self, dim, nb_pts, gd=None, tan=None, cotan=None):
        assert (gd is None) or (gd.shape[0] == dim*nb_pts)
        assert (tan is None) or (tan.shape[0] == dim*nb_pts)
        assert (cotan is None) or (cotan.shape[0] == dim*nb_pts)
        super().__init__()
        
        self.__nb_pts = nb_pts
        self.__dim = dim
        self.__dim_gd = nb_pts*dim

        self.__gd = torch.zeros(nb_pts, dim).view(-1).requires_grad_()
        if isinstance(gd, torch.Tensor):
            self.fill_gd(gd)

        self.__tan = torch.zeros(nb_pts, dim).view(-1).requires_grad_()
        if isinstance(tan, torch.Tensor):
            self.fill_tan(tan)

        self.__cotan = torch.zeros(nb_pts, dim).view(-1).requires_grad_()
        if isinstance(cotan, torch.Tensor):
            self.fill_cotan(cotan)

    @property
    def nb_pts(self):
        return self.__nb_pts

    @property
    def dim(self):
        return self.__dim

    @property
    def dim_gd(self):
        return self.__dim_gd

    def __get_gd(self):
        return self.__gd

    def __get_tan(self):
        return self.__tan

    def __get_cotan(self):
        return self.__cotan

    def fill(self, manifold):
        self.fill_gd(manifold.gd)
        self.fill_tan(manifold.tan)
        self.fill_cotan(manifold.cotan)

    def fill_gd(self, gd):
        self.__gd = gd

    def fill_tan(self, tan):
        self.__tan = tan

    def fill_cotan(self, cotan):
        self.__cotan = cotan

    gd = property(__get_gd, fill_gd)
    tan = property(__get_tan, fill_tan)
    cotan = property(__get_cotan, fill_cotan)

    def muladd_gd(self, gd, scale):
        if isinstance(gd, torch.Tensor):
            self.__gd = self.__gd + scale*gd
        else:
            self.__gd = self.__gd + scale*gd.__gd

    def muladd_tan(self, tan, scale):
        if isinstance(tan, torch.Tensor):
            self.__tan = self.__tan + scale*tan
        else:
            self.__tan = self.__tan + scale*tan.__tan

    def muladd_cotan(self, cotan, scale):
        if isinstance(cotan, torch.Tensor):
            self.__cotan = self.__cotan + scale*cotan
        else:
            self.__cotan = self.__cotan + scale*cotan.__cotan

    def inner_prod_module(self, module):
        man = self.action(module)
        return torch.dot(self.__cotan.view(-1), man.tan.view(-1))

    def action(self, module) :
        """Applies the vector field generated by the module on the landmark."""
        tan = module(self.__gd.view(-1, self.__dim)).view(-1)
        return Landmarks(self.__dim, self.__nb_pts, gd=self.__gd, tan=tan)


class CompoundManifold(Manifold):
    def __init__(self, manifold_list):
        super().__init__()
        self.__manifold_list = manifold_list
        self.__dim = self.__manifold_list[0].dim
        self.__nb_pts = sum([m.nb_pts for m in self.__manifold_list])
        self.__dim_gd = sum([m.dim_gd for m in self.__manifold_list])

    @property
    def manifold_list(self):
        return self.__manifold_list

    @property
    def nb_manifold(self):
        return len(self.__manifold_list)

    def __getitem__(self, index):
        return self.__manifold_list[index]

    @property
    def dim(self):
        return self.__dim

    @property
    def nb_pts(self):
        return self.__nb_pts

    @property
    def dim_gd(self):
        return self.__dim_gd

    def __get_gd(self):
        return [m.gd for m in self.__manifold_list]

    def __get_tan(self):
        return [m.tan for m in self.__manifold_list]

    def __get_cotan(self):
        return [m.cotan for m in self.__manifold_list]

    def fill(self, manifold):
        self.fill_gd(manifold.gd)
        self.fill_tan(manifold.tan)
        self.fill_cotan(manifold.cotan)

    def fill_gd(self, gd):
        assert len(gd) == self.nb_manifold
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].fill_gd(gd[i])

    def fill_tan(self, tan):
        assert len(tan) == self.nb_manifold
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].fill_tan(tan[i])

    def fill_cotan(self, cotan):
        assert len(cotan) == self.nb_manifold
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].fill_cotan(cotan[i])

    gd = property(__get_gd, fill_gd)
    tan = property(__get_tan, fill_tan)
    cotan = property(__get_cotan, fill_cotan)

    def muladd_gd(self, gd, scale):
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].muladd_gd(gd[i], scale)

    def muladd_tan(self, tan, scale):
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].muladd_tan(tan[i], scale)

    def muladd_cotan(self, cotan, scale):
        for i in range(len(self.__manifold_list)):
            self.__manifold_list[i].muladd_cotan(cotan[i], scale)

    def inner_prod_module(self, module):
        return sum([m.inner_prod_module(module) for m in self.__manifold_list])

    def action(self, module):
        actions = []
        for m in self.__manifold_list:
            actions.append(m.action(module))

        return CompoundManifold(actions)

