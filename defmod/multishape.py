import torch
import numpy as np

from .kernels import K_xx, K_xy


class MultiShapeModule(torch.nn.Module):


    def __init__(self, module_list, constraints, segmentation):
        # module_list: list of submodules
        # constraints: constraints operator matrix
        # segmentation: binary image
        super().__init__()
        
        
        
        
        
    def __call__(self, gd, controls, points) :
        # points as a list
        # use helper function to check which module each point belongs to
        # reorder list of points wrt module they belong to
        
        # apply call function of each submodule
        app_list = []
        for i in range(self.__nb_module):
            app_list.append(self.__module_list[i](
                gd[self.__indice_gd[i]:self.__indice_gd[i+1]],
                controls[self.__indice_controls[i]:self.__indice_controls[i+1]],
                points[self.__indice_gd[i]:self.__indice_gd[i+1]]
            ).unsqueeze(0))
        return torch.sum(torch.cat(app_list), 0)
    
    
    def action(self, gd, module, gd_module, controls_module) :
        """Applies the vector field generated by Mod on GeoDesc."""
        
        return 
        
        
    def cost(self, gd, controls) :
        """Returns the cost."""
        # sum of costs for each submodule
        cost_list = []
        for i in range(self.__nb_module):
            cost_list.append(self.__module_list[i].cost(
                gd[self.__indice_gd[i]:self.__indice_gd[i+1]],
                controls[self.__indice_controls[i]:self.__indice_controls[i+1]]
            ).unsqueeze(0))
        return torch.sum(torch.cat(cost_list), 0)
    
    
    def inverse_cost(self, delta, GeoDesc):
        """Apply inverse cost operator"""
        # corresponds to compute_geodesic_control() in deformationmodule
        return 
    
    
    def constraints(self, modules, gd, controls, boundary_points):
        """ Computes the value of Constraints on v """
        
        return 